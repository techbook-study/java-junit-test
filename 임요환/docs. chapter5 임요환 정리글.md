# 2부 빠른 암기법 습득
## 좋은 테스트의 FIRST 속성
- 테스트도 유지보수해야하는 코드임
- 문제점 있는 테스트
    - 테스트를 사용하는 사람에게 어떤 정보도 주지 못하는 테스트
    - 산발적으로 실패하는 테스트
    - 어떤 가치도 증명하지 못하는 테스트
    - 실행하는 데 오래걸리는 테스트
    - 코드를 충분히 커버하지 못하는 테스트
    - 구현과 강하게 결합되어 있는 테스트, 따라서 작은 변화에도 다수의 테스트가 깨짐
    - 수많은 설정 고리로 점프하는 난해한 테스트

### FIRST: 좋은 테스트 조건
- [F]ast : 빠른
- [I]solated : 고립된
- [R]epeatable : 반복 가능한
- [S]elf-validating : 스스로 검증가능한
- [T]imely : 적시의

### [F]IRST: 빠르다
- 설께를 깨끗하게 하면 테스트를 빠르게 유지할 수 있음
- 느린 테스트에 대한 의존성을 줄여야함(예: 데이터베이스 호출)

### F[I]RST: 고립시킨다
- 직접적, 간접적으로 테스트 코드와 상호 작용하는 코드가 많을 수록 문제가 발생할 확률이 높음
- 데이터베이스 호출같은 경우 여러 문제를 불러일으킬 수 있음
- 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않음 -> 의존성 악순환
- 테스트 코드는 어떤 순서나 시간에 관계없이 실행할 수 있어야 함
- SRP를 고려하여 클래스를 설계하고 테스트 메서드에서도 적용하자

### FI[R]ST: 좋은 테스트는 반복 가능해야 한다
- 반복 가능한 테스트는 실행할 때마다 결과가 같아야 함
- 반복 가능하게 할려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리시켜야 함
- 시간 변화에 독립성을 유지하는 방법으로 목 객체를 사용할 수 있음

### FIR[S]T: 스스로 검증 가능하다
- 기대하는 것이 무엇인지 단언(Assertion)하지 않으면 테스트가 아님
- 테스트에 필요한 어떤 설정 단계든 자동화를 해야함
- 테스트를 실행하는 데 외부 설정이 필요하다면 FIRST 중에 I(고립성) 부분을 위반한 것임

### FIRS[T]: 적시에 사용한다
- 언제라도 단위 테스트를 작성할 수 있음 -> 가능하면 적절한 순간에 단위 테스트에 집중하는 것이 나음
- 단위 테스트로 코드를 검증하는 것을 미루는 것은 치석이 끼고 충치가 늘어나는 행위와 같음
- 옛날 코드에 대한 테스트는 시간 낭비가 될 수도 있음