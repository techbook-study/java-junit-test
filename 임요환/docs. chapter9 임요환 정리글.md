## 더 큰 설계 문제
- 리팩토링은 코드의 유지 보수 비용을 지속적으로 낮추어 줌
- 작은 클래스를 만들어 유연성과 테스트 용이성을 높임
- 명령-질의 분리를 통해 부작용을 만들고 동시에 값을 반환하여 사용자를 기만하는 메서드를 만들지 않도록 함

### Profile 클래스와 SRP
- 다수의 책임을 가진 큰 클래슨는 재사용하기 얼여ㅜㅁ
- SOLID 클래스의 설계 원칙
    - 단일 책임 원칙(SRP): 클래스는 변경할 때 한가지 이유만 있어야 함, 클랫는 작고 단일 목적을 추구함
    - 개방 폐쇄 원칙(OCP): 클래스는 확장에 열려 있고 변경에는 닫혀 있어야 함, 기존 클래스의 변경을 최소화해야 함
    - 리스코프 치환 원칙(LSP): 하위 타입은 반드시 상위 타입을 대체할 수 있어야 함, 클라이언트 입장에서 오버라이딩한 메서드가 기능성을 깨면 안됨
    - 인터페이스 분리 원칙(ISP): 클라이언트는 필요하지 않는 메서드에 의존하면 안됨, 커다란 인터페이스를 다수의 작은 인터페이스로 분할하는게 나음
    - 의존성 역전 원칙(DIP): 고수준 모듈은 저수준 모듈을 의존해서는 안됨, 둘다 추상화 클래스에 의존해야 함, 추상 클래스는 구체 클래스에 의존해서는 안됨, 구체 클래스는 추상 클래스에 의존해야 함

### 새로운 클래스 추출
- 클래스를 설계할 때 개념에 매핑하되 구체적인 생각에 매핑하지 말 것
- 설계는 코드를 변경하는 모든 곳에 존재하며 클래스 수준의 상호 작용이 아니라 유지 보수의 모든 측면에 집중해야 함

### 명령-질의 분리
- 어떤 값을 반환하고 부작용을 발생시키는 메서드는 명령-질의 분리(command-query separation) 원칙을 위반함
- 어떤 메서드는 명령을 실행(부작용을 생성하는 어떤 작업을 함)하거나 질의에 대답(어떤 값 반환)할 수 있으며 두 작업을 모두하면 안됨

### 단위 테스트의 유지 보수 비용
- 리팩토링은 코드 동작을 변경하지 않고 코드 구현을 바꾸는 활동임
- 깨진 테스트 코드를 고치는 비용은 돌아오는 가치가 훨씬 크기 때문에 고치는게 나음

#### 자신을 보호하는 방법
- 코드 중복은 가장 큰 설계 문제임
    - 코드 중복은 테스트를 따르기가 어려워짐
    - 작은 코드 조각들을 단일 메서드로 추출하면 그 코드 조각들을 변경해야 할 때 미치는 영향을 최소화 할 수 있음
- 단위 테스트를 작성하는데 코드가 몇 줄 혹은 수십 줄이 필요하다면 그것은 설계에 무제가 있는 것임 -> SRP를 위반할 가능성이 높고 이는 다른 클래스에 대한 의존성이 커짐 -> 클래스를 분할해야 함
- private 메서드(구현 세부 사항)을 테스트하려는 충동은 클래스가 필요 이상으로 커졌다는 얘기임 -> private 메서드가 자꾸 늘어나면 내부 동작을 새 클래스로 옮기고 public으로 만드는 것이 좋음

### 깨진 테스트 고치기
- 코드를 새로운 클래스들로 추출하면 작성한 테스트가 좀 더 직관적이고 작성하기 쉬워짐
- 테스트 작성이 쉬워지면 더 많은 순열(premutation)을 커버하는 경향이 있음

### 다른 설계에 관한 생각들
- 매번 무언가를 하는 것이 성능 저하로 이어진다면 지연 초기화(lazy initialization)을 사용하여 해결할 수 있음
- 시스템 설계에 대해 비판적인 눈을 유지하고 최상의 설계는 없다는 것을 명심해야 함

### 마치며
- 설계를 지속적으로 개선해 나가는 자신감을 키우기 위해 단위 테스트의 커버리지를 높여야 함
- SRP, 명령-질의 분리 같은 설계 원칙들을 기반으로 설계를 개선하는 데 집중함
- 설계에 관한 앞선 원칙과 다른 커다란 개념들을 가능한 많이 알아 두는게 좋음
- 설계에 관한 작은 개념들과 작은 코드 리팩토링이 어떻게 커다란 차이를 만들어 내는지도 이해해야 함
- 기꺼이 새롭고 작은 클래스들을과 메서드들을 만들어라