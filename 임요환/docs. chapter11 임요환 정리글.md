## 테스트 리팩토링
- 테스트 코드도 상당한 비용 투자가 필요하며 변경이 빈번하게 일어날 수 있음
- 이를 위해 테스트 코드도 리팩토링하여 이해도를 최대화하며 유지 보수 비용을 최소화해야 함

### 이해 검색
- 리팩토링을 통해 좀 더 깔끔하고 표현력이 좋은 테스트로 만들어야 함

### 테스트 냄새: 불필요한 테스트 코드
- JUnit에서는 예외를 잡을 필요가 없음(try-catch 사용 x)
- 불필요한 단언은 제거함

### 테스트 냄새: 추상화 누락
- 같은 맥락의 여러 줄의 단언 코드를 한줄의 코드로 줄일 수 있도록 노력해야 함
- 사용자 정의 매처 클래스들을 만들어 사용하여도 좋음

### 테스트 냄새: 부적절한 정보
- 매직 리터럴을 제거하고 의미 있는 이름을 가진 상수를 도입하여 즉시 파악할 수 있도록 함

### 테스트 냄새: 부푼 생성
- 도우미 메서드들을 만들어 정신 산란한 세부 사항을 숨기는게 테스트를 좀 더 간결하게 만들 수 있음

### 테스트 냄새: 다수의 단언
- 테스트마다 단언은 한 개로 가는 방향이 좋으며 여러 개의 단언이 있다는 것은 테스트 케이스를 두 개 포함하고 있다는 증거임
- 테스트를 두개로 분할하여 각각을 좀 더 간결하게 테스트 맥락에 맞도록 기대하는 행동을 기술 할 수 있음
- 단일 목적으 테스트는 불필요한 주석을 제거하여 더 나은 테스트 이름으로 대신할 수 있음

### 테스트 냄새: 테스트와 무관한 세부 사항들
- 테스트와 무관한 부분들은 @Before, @After, 도우미 메서드들을 통해 코드를 간결하게 만듬
- 좋은 테스트는 테스트를 이해하는 데 다른 함수를 파헤치지 않도록 함

### 테스트 냄새: 잘못된 조직
- 빈 줄을 사용하여 준비(Arrange), 실행(Act), 단언(Assert) 부분을 나눠 의미를 분명하게 함

### 테스트 냄새: 암시적 의미
- 각 테스트는 "왜 그러한 결과를 기대하는가?"를 대답해야 하며 테스트 준비와 단언 부분을 상호 연관 지을 수 있어야함
- 단언이 기대하는 이유가 분명하지 않으면 코드를 읽는 사람들은 그 코드를 이해하기 위해 시간을 낭비하게 됨
- 테스트 데이터를 명시적으로 바꾸어 테스트 데이터를 보아도 이해할 수 있는 내용으로 데이터를 변경함
- 테스트를 걸쳐 상호 관련성을 향상시키는 방법은 무한함(의미 있는 상수, 더 좋은 변수 이름, 더 좋은 데이터와 때떄로 테스트에서 계산을 적게 만드는 것 등)

### 새로운 테스트 추가
- 위의 과정들을 통해 새로운 테스트를 추가하는데 많은 시간을 들이지 않아도 됨

### 마치며
- 리팩토링된 테스트들은 단순해지며 이해하기 쉬워짐
- 설계란 프로덕션 코드를 깔끔하고 간결하게 리팩토링하고, 프로덕션 코드를 설계할 때 더 많은 유연성을 제공하도록 리팩토링하고, 시스템의 의존성 도전 과제에 대해 목을 지원하고, 유지 보수 비용을 최소화하고, 이해도를 최대화하도록 테스트를 리팩토링하는 것임