# 4부 더 큰 단위 테스트 그림
## 테스트 주도 개발
- 레거시 코드가 느는 이유는 단위 테스트에 대한 관심이 부족하기 떄문임

### TDD의 주된 이익
- 코드가 예상한 대로 동작한다는 자신감을 얻음
- 코드가 변경될 것이라는 두려움을 지을 수 있음 -> 구현하는 모든 사례에 대해 단위테스트를 작성하기 때문

### 단순하게 시작
- TDD 사이클
    - 실패하는 테스트 코드 작성하기
    - 테스트 통과시키기
    - 이전 두 단계에서 추가되거나 변경된 코드 개선하기
- TDD의 점진적인 사고방식을 따르는 것이 중요함
- 백업하거나 방향을 반대로 돌리기 위해 사이클마다 커밋을 함

### 또 다른 증분 추가
- 테스트는 시스템을 문서화함 -> 추측에 근거한 개발이라는 잠재적 낭비를 피하게 됨
- 가장 작은 양의 코드를 작성하는 것은 먼저 실패하는 다른 테스트를 만들 수 있다는 의미임
- 결함이 있을ㄷ 때 바로 알아낼 수 있음

### 테스트 정리
- @Before 등을 사용하여 테스트 코드 리팩터링
- 테스트는 짧고 깔끔해야 함
- 테스트를 먼저 작성하기 때문에 리팩터링에 수월함

### 또 다른 작은 증분
- 작성할 필요가 있는 다음 테스트를 결정하는 것을 생각해야 함
- 프로그래머의 임무는 코드가 다루어야 하는 모든 가능한 순열과 시나리오를 이해하는 것임
- 시나리오의 테스트를 통과하게 만드는 코드 증분을 최소화하는 순으로 코드를 작성해야 함

### 다수의 응답 지원: 작은 설계 우회로
- 필요한 사항이 있다면 설계를 변경하여 다른 클래스로 넘어가도 됨

### 인터페이스 확장
- 하드코딩은 빠르게 다음 테스트를 작성하게 해주며 사이클을 짧게 유지하는데 도움을 줌
- AAA는 불변의 법칙이 아님

### 문서로서의 테스트
- 테스트 이름들을 통해 문서를 유추할 수 있음
- 세심한 테스트들은 더 많이 문서화할 수 있음
- 포괄적인 테스트 이름의 집합은 클래스의 의도된 용량을 전체적인 관점 요약으로 제공함
- 테스트 이름이 다른 것들과 함께 깔끔하고 일관성이 있을수록 더 신뢰할 수 있는 클래스 문서가 됨

### TDD의 리듬
- 테스트 > 코드 > 리팩토링 사이클
- 10분 정도의 시간을 제한을 두어 테스트 통과를 하지 못한다면 해당 코드를 폐기하고 다시 좀더 작은 단계로 도전하는 걸 권장함 -> 이 과정을 통해 나쁜 코드를 버릴 수 있고 가정의 범위를 축소하여 문제를 더 쉽게 찾을 수 있음