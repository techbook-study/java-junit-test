## 경계조건: CORRECT 암기법
- Conformance(준수) : 값이 기대한 양식을 준수하고 있는가?
- Ordering(순서) : 값의 집합이 적절하게 정렬되거나 정렬되지 않았나?
- Range(범위) : 이성적인 최솟값과 최댓값 안에 있는가?
- Reference(참조) : 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
- Existence(존재) : 값이 존재하거나(널이 아니거나, 0이 아니거나, 집합에 존재하는가 등)?
- Cardinality(기수) : 정확히 충분한 값들이 있는가?
- Time(절대적 혹은 상대적 시간) : 모든 것이 순서대로 일어나는가? 정확한 시간에? 정시에?
- 그 밖의 문제될 것이 있는가?

### [C]ORRECT: [C]onformance(준수)
- 이메일 주소는 이메일 형식을 따라야 함
- 이메일 주소, 전화번호, 계좌 번호, 파일 이름 등 양식이 있는 문자열 데이터를 검증할 때는 많은 규칙이 필요함

### C[O]RRECT: [O]rdering(순서)
- 데이터 순서 혹은 커다란 컬렉션에 있는 데이터 한 조각의 위치는 코드가 쉽게 잘못될 수 있음
- 예) compareTo 메서드에 인자 값의 순서가 바뀌어 넘어갈 때

### CO[R]RECT: [R]ange(범위)
- 기본형의 과도한 사용에 대한 냄새 = 기본형 중독(primitive obsession)
- 객체지향 언어의 장점은 사용자 정의 추상화를 클래스로 만들 수 있음
- int 형의 나이는 음수를 가질 수도 있으며 말도 안되는 큰 숫자를 가질 수 있음 -> 클래스로 만들어서 처리

#### 불변성을 검사하는 사용자 정의 매처 생성
- org.hamcrest.TypeSafeMatcher 클래스를 상속하여 커스텀 매처를 구현

#### 불변 메서드를 내장하여 범위 테스트
- 인덱스를 다룰 떄 고려해야할 부분
    - 시작과 마지막 인덱스가 같으면 안됨
    - 시작이 마지막보다 크면 안됨
    - 인덱스는 음수가 아니어야함
    - 인덱스가 허용된 것보다 크면 안됨
    - 개수가 실제 항목 개수와 맞아야 함

### COR[R]ECT: [R]eference(참조)
- 메서드 테스트시 고려할 점
    - 범위를 넘어서는 것을 참조하고 있지 않은지
    - 외부 의존성은 무엇인지
    - 특정 상태에 있는 객체를 의존하고 있는지 여부
    - 반드시 존재해야 하는 그 외 다른 조건들
- 메서드의 사전 조건들(preconditions)을 만족해야 사후 조건들을 테스트할 수 있음
- 사후 조건들(postconditions)은 코드가 참을 유지해야 하는 조건들을 의미하며 테스트의 단언으로 명시함
- 부작용(side effects)를 검사해야 할 필요도 있음

### CORR[E]CT: [E]xistence(존재)
- 스스로에게 "주어진 값이 존재하는가?"라고 물어봄으로써 많은 잠재적인 결함을 발견할 수 있음(null, 0, 비어 있는 경우)

### CORRE[C]T: [C]ardinality(기수)
- 기수의 특수한 경우 = 0-1-n 법칙
- 테스트할 시 0일 때 1일 때 n일 때를 생각하면 테스트할 작업 목록을 도출하는데 도움을 줌

### CORREC[T]: [T]ime(시간)
- 상대적 시간(시간 순서)
    - login은 logout 앞에서 일어나야 함
    - timeout 문제
- 절대적 시간(측정된 시간)
    - 표준 시간 차이로 발생되는 문제들
- 동시성 문제들

### 마치며
- 모든 경계를 알 필요는 없음
- 경계 조건들은 자주 고약하고 작은 결함등를 만들어 내는 곳임
- CORRECT 약어는 단위 테스트를 작성할 때 고려해야 하는 경계들을 기억하는 데 도움을 줌
